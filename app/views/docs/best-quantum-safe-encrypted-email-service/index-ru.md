# Квантово-устойчивая электронная почта: как мы используем зашифрованные почтовые ящики SQLite для защиты вашей электронной почты {#quantum-resistant-email-how-we-use-encrypted-sqlite-mailboxes-to-keep-your-email-safe}

<img loading="lazy" src="/img/articles/quantum.webp" alt="" class="rounded-lg" />

## Содержание {#table-of-contents}

* [Предисловие](#foreword)
* [Сравнение поставщиков услуг электронной почты](#email-service-provider-comparison)
* [Как это работает?](#how-does-it-work)
* [Технологии](#technologies)
  * [Базы данных](#databases)
  * [Безопасность](#security)
  * [Почтовые ящики](#mailboxes)
  * [Параллелизм](#concurrency)
  * [Резервные копии](#backups)
  * [Поиск](#search)
  * [Проекты](#projects)
  * [Поставщики](#providers)
* [Мысли](#thoughts)
  * [Принципы](#principles)
  * [Эксперименты](#experiments)
  * [Отсутствие альтернатив](#lack-of-alternatives)
  * [Попробуйте переслать письмо](#try-out-forward-email)

## Предисловие {#foreword}

> \[!IMPORTANT]
> Our email service is [100% open-source](https://github.com/forwardemail) and privacy-focused through secure and encrypted SQLite mailboxes.

До запуска [Поддержка IMAP](/faq#do-you-support-receiving-email-with-imap) мы использовали MongoDB для постоянного хранения данных.

Эта технология удивительна, и мы по-прежнему используем ее сегодня, но для того, чтобы использовать шифрование данных в состоянии покоя с помощью MongoDB, вам необходимо воспользоваться услугами провайдера, который предлагает MongoDB Enterprise, например Digital Ocean или Mongo Atlas, или заплатить за корпоративную лицензию (и впоследствии смириться с задержками в работе отдела продаж).

Нашей команде [Переслать письмо](https://forwardemail.net) требовалось удобное для разработчиков, масштабируемое, надежное и зашифрованное решение для хранения почтовых ящиков IMAP. Как разработчикам ПО с открытым исходным кодом, использование технологии, требующей оплаты лицензии за шифрование данных в состоянии покоя, противоречило [наши принципы](#principles), поэтому мы провели эксперименты, исследования и разработали новое решение с нуля для решения этих задач.

Вместо того чтобы использовать общую базу данных для хранения ваших почтовых ящиков, мы индивидуально храним и шифруем ваши почтовые ящики с помощью вашего пароля (который есть только у вас). **Наш почтовый сервис настолько безопасен, что если вы забудете свой пароль, то потеряете свой почтовый ящик** (и вам придется восстанавливать его с помощью резервных копий в автономном режиме или начинать заново).

Продолжайте читать, и ниже мы подробно рассмотрим [сравнение поставщиков услуг электронной почты](#email-service-provider-comparison), [как работает наш сервис](#how-does-it-work), [наш технологический стек](#technologies) и многое другое.

## Сравнение поставщиков услуг электронной почты {#email-service-provider-comparison}

Мы являемся единственным поставщиком услуг электронной почты с открытым исходным кодом, ориентированным на конфиденциальность, который хранит индивидуально зашифрованные почтовые ящики SQLite, предлагает неограниченное количество доменов, псевдонимов и пользователей, а также имеет поддержку исходящих протоколов SMTP, IMAP и POP3:

**В отличие от других поставщиков услуг электронной почты, вам не нужно платить за хранение на основе домена или псевдонима с Forward Email.** Хранилище распределяется по всей вашей учетной записи, поэтому, если у вас есть несколько пользовательских доменных имен и несколько псевдонимов на каждом, то мы являемся идеальным решением для вас. Обратите внимание, что вы по-прежнему можете применять ограничения на хранение, если хотите, на основе домена или псевдонима.

<a href="/blog/best-email-service" target="_blank" class="btn btn-lg bg-success text-white btn-block btn-success">Прочитать сравнение почтовых служб <i class="fa fa-search-plus"></i></a>

## Как это работает {#how-does-it-work}

1. Используя свой почтовый клиент, такой как Apple Mail, Thunderbird, Gmail или Outlook, вы подключаетесь к нашим защищенным серверам [IMAP](/faq#do-you-support-receiving-email-with-imap), используя свое имя пользователя и пароль:

* Ваше имя пользователя — это ваш полный псевдоним с вашим доменом, например, `hello@example.com`.
* Ваш пароль генерируется случайным образом и отображается только в течение 30 секунд после нажатия кнопки <strong class="text-success"><i class="fa fa-key"></i> «Сгенерировать пароль»</strong> из раздела <a href="/my-account/domains" target="_blank" rel="noopener noreferrer" class="alert-link">Моя учётная запись <i class="fa fa-angle-right"></i> Домены</a> <i class="fa fa-angle-right"></i> Псевдонимы.

2. После подключения ваш почтовый клиент отправит [Команды протокола IMAP](https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol) на наш IMAP-сервер для синхронизации вашего почтового ящика. Это включает в себя написание и хранение черновиков писем, а также другие действия, которые вы можете выполнять (например, отмечать письма как важные или как спам/нежелательную почту).

3. Почтовые серверы (обычно называемые MX-серверами) получают новые входящие письма и сохраняют их в вашем почтовом ящике. При этом ваш почтовый клиент получает уведомление и синхронизирует ваш почтовый ящик. Наши почтовые серверы могут пересылать ваши письма одному или нескольким получателям (включая [вебхуки](/faq#do-you-support-webhooks)), сохранять их в вашем зашифрованном IMAP-хранилище у нас, **или делать и то, и другое**!

> \[!СОВЕТ]
> Хотите узнать больше? Прочитайте [как настроить пересылку электронной почты](/faq#how-do-i-get-started-and-set-up-email-forwarding), [как работает наша служба обмена почтой](/faq#how-does-your-email-forwarding-system-work) или посетите [наши гиды](/guides).

4. За кулисами наша безопасная система хранения электронной почты работает двумя способами, чтобы ваши почтовые ящики были зашифрованы и доступны только вам:

* Когда вам приходит новое письмо от отправителя, наши серверы почтовой связи записывают его в индивидуальный, временный и зашифрованный почтовый ящик для вас.

     ```mermaid
     sequenceDiagram
         autonumber
         actor Sender
         Sender->>MX: Inbound message received for your alias (e.g. you@yourdomain.com).
         MX->>SQLite: Message is stored in a temporary mailbox.
         Note over MX,SQLite: Forwards to other recipients and webhooks configured.
         MX->>Sender: Success!
     ```

* Когда вы подключаетесь к нашему серверу IMAP с помощью своего почтового клиента, ваш пароль затем шифруется в памяти и используется для чтения и записи в ваш почтовый ящик. Ваш почтовый ящик может быть прочитан и записан только с этим паролем. Помните, что поскольку вы единственный, у кого есть этот пароль, **только вы** можете читать и писать в свой почтовый ящик, когда вы получаете к нему доступ. В следующий раз, когда ваш почтовый клиент попытается запросить почту или синхронизироваться, ваши новые сообщения будут переданы из этого временного почтового ящика и сохранены в вашем фактическом файле почтового ящика с использованием предоставленного вами пароля. Обратите внимание, что этот временный почтовый ящик впоследствии очищается и удаляется, так что сообщения остаются только в вашем защищенном паролем почтовом ящике.

* **Если вы подключены к IMAP (например, используя почтовый клиент, такой как Apple Mail или Thunderbird), то нам не нужно записывать во временное дисковое хранилище. Вместо этого извлекается и используется ваш зашифрованный в памяти пароль IMAP. В режиме реального времени, когда сообщение пытается быть доставлено вам, мы отправляем запрос WebSocket на все серверы IMAP, спрашивая их, есть ли у них активный сеанс для вас (это часть извлечения), а затем впоследствии передаем этот зашифрованный в памяти пароль — поэтому нам не нужно записывать во временный почтовый ящик, мы можем записывать в ваш фактический зашифрованный почтовый ящик, используя ваш зашифрованный пароль.**

     ```mermaid
     sequenceDiagram
         autonumber
         actor You
         You->>IMAP: You connect to IMAP server using an email client.
         IMAP->>SQLite: Transfer message from temporary mailbox to your alias' mailbox.
         Note over IMAP,SQLite: Your alias' mailbox is only available in-memory using IMAP password.
         SQLite->>IMAP: Retrieves messages as requested by email client.
         IMAP->>You: Success!
     ```

5. [Резервные копии ваших зашифрованных почтовых ящиков](#backups) создаются ежедневно. Вы также можете запросить новую резервную копию в любое время или скачать последнюю из них в разделе <a href="/my-account/domains" target="_blank" rel="noopener noreferrer" class="alert-link">Моя учётная запись <i class="fa fa-angle-right"></i> Домены</a> <i class="fa fa-angle-right"></i> Псевдонимы. Если вы решите перейти на другой почтовый сервис, вы сможете легко перенести, скачать, экспортировать и удалить свои почтовые ящики и резервные копии в любое время.

## Технологии {#technologies}

### Базы данных {#databases}

Мы изучили другие возможные уровни хранения базы данных, однако ни один из них не удовлетворял нашим требованиям так, как SQLite:

| База данных | Шифрование в состоянии покоя | [Sandboxed](https://en.wikipedia.org/wiki/Sandbox_\(computer_security\)) Почтовые ящики | Лицензия | [Used Everywhere](https://www.sqlite.org/mostdeployed.html) |
| ------------------------------------------------------ | :-----------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------: | :---------------------------------------------------------: | :---------------------------------------------------------: |
| **[SQLite](https://www.sqlite.org/index.html)** :star: | :white_check_mark: Да с [SQLite3MultipleCiphers](https://github.com/utelle/SQLite3MultipleCiphers) | :white_check_mark: | :white_check_mark: Общественное достояние | :white_check_mark: |
| [MongoDB](https://www.mongodb.com/) | :x: ["Available in MongoDB Enterprise only"](https://www.mongodb.com/docs/manual/core/security-encryption-at-rest/) | :x: Реляционная база данных | :x: AGPL и `SSPL-1.0` | :х: |
| [rqlite](https://github.com/rqlite/rqlite) | :x: [Network only](https://github.com/rqlite/rqlite/issues/1406) | :x: Реляционная база данных | :white_check_mark: `MIT` | :х: |
| [dqlite](https://dqlite.io/) | :x: [Untested and not yet supported?](https://github.com/canonical/dqlite/issues/32) | :x: [Untested and not yet supported?](https://github.com/canonical/dqlite/issues/32) | :white_check_mark: `LGPL-3.0-only` | :х: |
| [PostgreSQL](https://www.postgresql.org/) | :white_check_mark: [Yes](https://www.postgresql.org/docs/current/encryption-options.html) | :x: Реляционная база данных | :white_check_mark: `PostgreSQL` (аналогично `BSD` или `MIT`) | :х: |
| [MariaDB](https://mariadb.com/) | :white_check_mark: [For InnoDB only](https://mariadb.com/kb/en/data-at-rest-encryption-overview/#which-storage-engines-does-mariadb-encryption-support) | :x: Реляционная база данных | :white_check_mark: `GPLv2` и `BUSL-1.1` | :х: |
| [CockroachDB](https://www.cockroachlabs.com/product/) | :x: [Enterprise-only feature](https://www.cockroachlabs.com/docs/v23.1/enterprise-licensing) | :x: Реляционная база данных | :x: `BUSL-1.1` и другие | :х: |

> Вот [запись в блоге, в которой сравниваются несколько вариантов хранения баз данных SQLite](https://gcore.com/learning/comparing-litestream-rqlite-dqlite/) в таблице выше.

### Безопасность {#security}

Мы всегда используем шифрование почтовых ящиков [шифрование в состоянии покоя](https://en.wikipedia.org/wiki/Data_at_rest) ([AES-256](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)), [шифрование при передаче](https://en.wikipedia.org/wiki/Data_in_transit) ([TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)), [DNS через HTTPS](https://en.wikipedia.org/wiki/DNS_over_HTTPS) (DoH) с использованием :tangerine: [мандарин](https://tangeri.ne) и [SQLeet](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/) ([ChaCha20-Poly1305](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/)). Кроме того, мы используем двухфакторную аутентификацию на основе токенов (в отличие от SMS, которые вызывают подозрения у [атаки типа «человек посередине»](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)), ротацию SSH-ключей с отключенным root-доступом, эксклюзивный доступ к серверам через ограниченные IP-адреса и многое другое.

В случае [атака злой горничной](https://en.wikipedia.org/wiki/Evil_maid_attack) или действий недобросовестного сотрудника стороннего поставщика, **ваш почтовый ящик по-прежнему можно будет открыть только с помощью сгенерированного вами пароля**. Будьте уверены, мы не полагаемся ни на каких сторонних поставщиков, кроме наших поставщиков серверов для жалоб SOC Type 2: Cloudflare, DataPacket, Digital Ocean и Vultr.

Наша цель — сделать так, чтобы [единая точка отказа](https://en.wikipedia.org/wiki/Single_point_of_failure) было как можно меньше.

### Почтовые ящики {#mailboxes}

> **tldr;** Наши серверы IMAP используют индивидуально зашифрованные базы данных SQLite для каждого из ваших почтовых ящиков.

[SQLite — чрезвычайно популярный](https://www.sqlite.org/mostdeployed.html) встроенная база данных – в настоящее время она работает на вашем телефоне и компьютере – [и используется почти всеми основными технологиями](https://www.sqlite.org/famous.html).

Например, на наших зашифрованных серверах есть почтовый ящик базы данных SQLite для `linux@example.com`, `info@example.com`, `hello@example.com` и так далее — по одному файлу базы данных для каждого адреса `.sqlite`. Мы также не присваиваем имена файлам базы данных адресам электронной почты — вместо этого мы используем BSON ObjectID и уникальные UUID, которые не раскрывают, кому принадлежит почтовый ящик или какой адрес электронной почты он использует (например, `353a03f21e534321f5d6e267.sqlite`).

Каждая из этих баз данных зашифрована вашим паролем (который известен только вам) с помощью [SQLeet](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/) ([ChaCha20-Poly1305](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/)). Это означает, что ваши почтовые ящики зашифрованы индивидуально, автономны, [в песочнице](https://en.wikipedia.org/wiki/Sandbox_\(computer_security\) и портативны.

Мы настроили SQLite с помощью следующего [PRAGMA](https://www.sqlite.org/pragma.html):

| `PRAGMA` | Цель |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cipher=chacha20` | [ChaCha20-Poly1305 SQLite database encryption](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/). Для получения более подробной информации см. `better-sqlite3-multiple-ciphers` в разделе [Projects](#projects). |
| `key="****************"` | Это ваш расшифрованный пароль, хранящийся только в памяти, который передаётся через IMAP-подключение вашего почтового клиента на наш сервер. Для каждого сеанса чтения и записи создаются и закрываются новые экземпляры базы данных (для обеспечения изоляции и изоляции). |
| `journal_model=WAL` | Журнал предварительной записи ("[WAL](https://www.sqlite.org/wal.html)") [which boosts performance and allows concurrent read access](https://litestream.io/tips/#wal-journal-mode). |
| `busy_timeout=5000` | Предотвращает ошибки блокировки записи [while other writes are taking place](https://litestream.io/tips/#busy-timeout). |
| `synchronous=NORMAL` | Увеличивает долговечность транзакций [without data corruption risk](https://litestream.io/tips/#synchronous-pragma). |
| `foreign_keys=ON` | Обеспечивает принудительное использование ссылок на внешние ключи (например, связи между таблицами). [By default this is not turned on in SQLite](https://www.sqlite.org/foreignkeys.html), но для проверки достоверности и целостности данных ее следует включить. |
| `encoding='UTF-8'` | [Default encoding](https://www.sqlite.org/pragma.html#pragma_encoding) для использования с целью обеспечения работоспособности разработчика. |

> Все остальные значения по умолчанию взяты из SQLite, как указано в [официальная документация PRAGMA](https://www.sqlite.org/pragma.html#pragma_auto_vacuum).

### Параллелизм {#concurrency}

> **tldr;** Мы используем `WebSocket` для одновременного чтения и записи в ваши зашифрованные почтовые ящики SQLite.

#### Читает {#reads}

Ваш почтовый клиент на телефоне может преобразовать `imap.forwardemail.net` в один из наших IP-адресов Digital Ocean, а ваш настольный клиент может преобразовать отдельный IP-адрес из другого [поставщик](#providers).

Независимо от того, к какому серверу IMAP подключается ваш почтовый клиент, мы хотим, чтобы соединение считывало данные из вашей базы данных в режиме реального времени со 100% точностью. Это делается через WebSockets.

#### Записывает {#writes}

Запись в вашу базу данных немного отличается, поскольку SQLite — это встроенная база данных, а ваш почтовый ящик по умолчанию находится в одном файле.

Мы рассмотрели такие варианты, как `litestream`, `rqlite` и `dqlite`, однако ни один из них не удовлетворял нашим требованиям.

Чтобы выполнить запись с включенным опережающим протоколированием («[WAL](https://www.sqlite.org/wal.html)»), нам нужно убедиться, что за это отвечает только один сервер («основной»). [WAL](https://www.sqlite.org/wal.html) значительно ускоряет параллелизм и допускает одного писателя и нескольких читателей.

Основной сервер работает на серверах данных с подключенными томами, содержащими зашифрованные почтовые ящики. С точки зрения распределения все отдельные IMAP-серверы за `imap.forwardemail.net` можно считать вторичными серверами («Secondary»).

Мы осуществляем двустороннюю связь с помощью [Веб-сокеты](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket):

* Основные серверы используют экземпляр сервера `WebSocketServer` [ws](https://github.com/websockets/ws).
* Вторичные серверы используют экземпляр клиента `WebSocket` [ws](https://github.com/websockets/ws), обёрнутый [вебсокет-как-обещано](https://github.com/vitalets/websocket-as-promised) и [повторное подключение-websocket](https://github.com/opensumi/reconnecting-websocket). Эти две обёртки обеспечивают повторное подключение `WebSocket` и возможность отправки и получения данных для определённых операций записи в базу данных.

### Резервные копии {#backups}

> **tldr;** Резервные копии ваших зашифрованных почтовых ящиков создаются ежедневно. Вы также можете мгновенно запросить новую резервную копию или загрузить последнюю резервную копию в любое время из <a href="/my-account/domains" target="_blank" rel="noopener noreferrer" class="alert-link">Моя учетная запись <i class="fa fa-angle-right"></i> Домены</a> <i class="fa fa-angle-right"></i> Псевдонимы.

Для резервного копирования мы просто запускаем команду SQLite `VACUUM INTO` каждый день во время обработки команды IMAP, которая использует ваш зашифрованный пароль из IMAP-подключения в памяти. Резервные копии сохраняются, если существующая резервная копия не обнаружена или если хеш [SHA-256](https://en.wikipedia.org/wiki/SHA-2) файла изменился по сравнению с последней резервной копией.

Обратите внимание, что мы используем команду `VACUUM INTO` вместо встроенной команды `backup`, поскольку если страница будет изменена во время выполнения команды `backup`, её придётся начать заново. Команда `VACUUM INTO` создаст снимок. Подробнее см. комментарии к [GitHub](https://github.com/benbjohnson/litestream.io/issues/56) и [Хакерские новости](https://news.ycombinator.com/item?id=31387556).

Кроме того, мы используем `VACUUM INTO` вместо `backup`, поскольку команда `backup` оставит базу данных незашифрованной на короткий период времени, пока не будет вызвана `rekey` (для получения более подробной информации см. GitHub [комментарий](https://github.com/m4heshd/better-sqlite3-multiple-ciphers/issues/46#issuecomment-1468018927)).

Вторичный сервер даст указание первичному серверу по соединению `WebSocket` выполнить резервное копирование, а первичный сервер получит команду на выполнение этого и затем выполнит следующее:

1. Подключитесь к своему зашифрованному почтовому ящику.
2. Получите блокировку записи.
3. Запустите контрольную точку WAL через `wal_checkpoint(PASSIVE)`.
4. Выполните команду SQLite `VACUUM INTO`.
5. Убедитесь, что скопированный файл можно открыть с помощью зашифрованного пароля (защита/фиктивная защита).
6. Загрузите его в хранилище Cloudflare R2 (или на ваш провайдер, если указано).

<!--
7. Сожмите полученный файл резервной копии с помощью `gzip`.
8. Загрузите его в Cloudflare R2 для хранения (или на ваш провайдер, если указано).
-->

Помните, что ваши почтовые ящики зашифрованы, и хотя у нас есть ограничения по IP-адресам и другие меры аутентификации для связи по протоколу WebSocket, в случае взлома злоумышленника вы можете быть уверены, что если в полезной нагрузке WebSocket нет вашего пароля IMAP, он не сможет открыть вашу базу данных.

В настоящее время для каждого почтового ящика хранится только одна резервная копия, но в будущем мы можем предложить восстановление на определенный момент времени («[PITR](https://en.wikipedia.org/wiki/Point-in-time_recovery)»).

### Поиск {#search}

Наши серверы IMAP поддерживают команду `SEARCH` со сложными запросами, регулярными выражениями и многим другим.

Высокая производительность поиска достигается благодаря [FTS5](https://www.sqlite.org/fts5.html) и [sqlite-regex](https://github.com/asg017/sqlite-regex#sqlite-regex).

Значения `Date` сохраняются в почтовых ящиках SQLite как строки [ISO 8601](https://en.wikipedia.org/wiki/ISO\_8601) через [Date.prototype.toISOString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString) (с часовым поясом UTC для корректной работы сравнений на равенство).

Индексы также сохраняются для всех свойств, которые есть в поисковых запросах.

### Проекты {#projects}

Ниже представлена таблица с описанием проектов, которые мы используем в нашем исходном коде и процессе разработки (в алфавитном порядке):

| Проект | Цель |
| --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Ansible](https://www.ansible.com/) | Платформа автоматизации DevOps для простого обслуживания, масштабирования и управления всем нашим парком серверов. |
| [Bree](https://github.com/breejs/bree) | Планировщик заданий для Node.js и JavaScript с cron, датами, ms, later и удобной для пользователя поддержкой. |
| [Cabin](https://github.com/cabinjs/cabin) | Удобная для разработчиков библиотека журналирования JavaScript и Node.js, ориентированная на безопасность и конфиденциальность. |
| [Lad](https://github.com/ladjs/lad) | Фреймворк Node.js, на котором базируется вся наша архитектура и инженерное проектирование с использованием MVC и других основ. |
| [MongoDB](https://www.mongodb.com/) | Решение базы данных NoSQL, которое мы используем для хранения всех остальных данных за пределами почтовых ящиков (например, вашей учетной записи, настроек, доменов и конфигураций псевдонимов). |
| [Mongoose](https://github.com/Automattic/mongoose) | Объектно-документное моделирование (ODM) MongoDB, которое мы используем во всем нашем стеке. Мы написали специальные вспомогательные функции, которые позволяют нам просто продолжать использовать **Mongoose с SQLite** :tada: |
| [Node.js](https://nodejs.org/en) | Node.js — это кроссплатформенная среда выполнения JavaScript с открытым исходным кодом, которая запускает все наши серверные процессы. |
| [Nodemailer](https://github.com/nodemailer/nodemailer) | Пакет Node.js для отправки электронных писем, создания связей и многого другого. Мы являемся официальным спонсором этого проекта. |
| [Redis](https://redis.io/) | База данных в памяти для кэширования, каналов публикации/подписки и запросов DNS по HTTPS. |
| [SQLite3MultipleCiphers](https://github.com/utelle/SQLite3MultipleCiphers) | Расширение шифрования для SQLite, позволяющее шифровать целые файлы базы данных (включая журнал предварительной записи ("[WAL](https://www.sqlite.org/wal.html)"), журнал, откат и т. д.). |
| [SQLiteStudio](https://github.com/pawelsalawa/sqlitestudio) | Визуальный редактор SQLite (который вы также можете использовать) для тестирования, загрузки и просмотра почтовых ящиков разработки. |
| [SQLite](https://www.sqlite.org/about.html) | Встроенный уровень базы данных для масштабируемого, автономного, быстрого и отказоустойчивого хранилища IMAP. |
| [Spam Scanner](https://github.com/spamscanner/spamscanner) | Инструмент Node.js для борьбы со спамом, фильтрации электронной почты и предотвращения фишинга (наша альтернатива [Spam Assassin](https://spamassassin.apache.org/) и [rspamd](https://github.com/rspamd/rspamd)). |
| [Tangerine](https://tangeri.ne) | Запросы DNS через HTTPS с использованием Node.js и кэширование с использованием Redis, что обеспечивает глобальную согласованность и многое другое. |
| [Thunderbird](https://www.thunderbird.net/) | Наша команда разработчиков использует его (и рекомендует) как **предпочтительный почтовый клиент для пересылки электронной почты**. |
| [UTM](https://github.com/utmapp/UTM) | Наша команда разработчиков использует эти виртуальные машины для iOS и macOS для тестирования различных почтовых клиентов (параллельно) с нашими серверами IMAP и SMTP. |
| [Ubuntu](https://ubuntu.com/download/server) | Современная серверная операционная система на базе Linux с открытым исходным кодом, которая обеспечивает работу всей нашей инфраструктуры. |
| [WildDuck](https://github.com/nodemailer/wildduck) | Библиотека сервера IMAP – см. примечания к [attachment de-duplication](https://github.com/nodemailer/wildduck/blob/master/docs/in-depth/attachment-deduplication.md) и [IMAP protocol support](https://github.com/nodemailer/wildduck/blob/master/docs/in-depth/protocol-support.md). |
| [better-sqlite3-multiple-ciphers](https://github.com/m4heshd/better-sqlite3-multiple-ciphers) | Быстрая и простая API-библиотека для Node.js для программного взаимодействия с SQLite3. |
| [email-templates](https://github.com/forwardemail/email-templates) | Удобная для разработчиков платформа электронной почты, позволяющая создавать, просматривать и отправлять пользовательские письма (например, уведомления об учетной записи и многое другое). |
| [json-sql-enhanced](https://github.com/forwardemail/json-sql-enhanced) | Конструктор SQL-запросов с синтаксисом в стиле Mongo. Это экономит время нашей команды разработчиков, поскольку мы можем продолжать писать в стиле Mongo для всего стека, используя подход, не зависящий от базы данных. **Это также помогает избежать атак SQL-инъекций благодаря использованию параметров запроса.** |
| [knex-schema-inspector](https://github.com/knex/knex-schema-inspector) | Утилита SQL для извлечения информации о существующей схеме базы данных. Это позволяет нам легко проверить корректность всех индексов, таблиц, столбцов, ограничений и т.д. и их соответствие `1:1` требованиям. Мы даже написали автоматизированные помощники для добавления новых столбцов и индексов при внесении изменений в схемы базы данных (с очень подробными оповещениями об ошибках). |
| [knex](https://github.com/knex/knex) | Конструктор SQL-запросов, который мы используем только для миграции баз данных и проверки схемы через `knex-schema-inspector`. |
| [mandarin](https://github.com/ladjs/mandarin) | Автоматический перевод фразы [i18n](https://en.wikipedia.org/wiki/Internationalization_and_localization) с поддержкой Markdown с использованием [Google Cloud Translation API](https://cloud.google.com/translate/docs/reference/rest). |
| [mx-connect](https://github.com/zone-eu/mx-connect) | Пакет Node.js для разрешения и установления соединений с серверами MX и обработки ошибок. |
| [pm2](https://github.com/Unitech/pm2) | Менеджер производственных процессов Node.js со встроенным балансировщиком нагрузки ([fine-tuned](https://github.com/Unitech/pm2/issues/5145#issuecomment-1737764214) для производительности). |
| [smtp-server](https://github.com/nodemailer/smtp-server) | Библиотека сервера SMTP — мы используем ее для нашего почтового обмена («MX») и исходящих SMTP-серверов. |
| [ImapTest](https://www.imapwiki.org/ImapTest) | Полезный инструмент для тестирования IMAP-серверов на соответствие эталонным тестам и спецификации RFC. Этот проект был создан командой [Dovecot](https://en.wikipedia.org/wiki/Dovecot_\(software\) (активный сервер IMAP и POP3 с открытым исходным кодом с июля 2002 года). Мы провели тщательное тестирование нашего IMAP-сервера с помощью этого инструмента. |

> Вы можете найти другие проекты, которые мы используем, в [наш исходный код на GitHub](https://github.com/forwardemail).

### Поставщики {#providers}

| Поставщик | Цель |
| ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| [Cloudflare](https://www.cloudflare.com/) | Поставщик DNS, проверки работоспособности, балансировщики нагрузки и резервное хранилище с использованием [Cloudflare R2](https://developers.cloudflare.com/r2). |
| [Digital Ocean](https://m.do.co/c/a7fe489d1b27) | Выделенный серверный хостинг и управляемые базы данных. |
| [Vultr](https://www.vultr.com/?ref=7429848) | Хостинг выделенного сервера. |
| [DataPacket](https://www.datapacket.com) | Хостинг выделенного сервера. |

## Мысли {#thoughts}

### Принципы {#principles}

Пересылка электронной почты разработана в соответствии со следующими принципами:

1. Всегда будьте дружелюбны к разработчикам, ориентированы на безопасность и конфиденциальность, а также прозрачны.
2. Соблюдайте [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller), [Unix](https://en.wikipedia.org/wiki/Unix_philosophy), [KISS](https://en.wikipedia.org/wiki/KISS_principle), [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it), [Двенадцать факторов](https://12factor.net/), [Бритва Оккама](https://en.wikipedia.org/wiki/Occam%27s_razor) и [догфудинг](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)
3. Ориентируйтесь на нетребовательных, самостоятельных и [рамен-прибыльный](http://www.paulgraham.com/ramenprofitable.html) разработчиков.

### Эксперименты {#experiments}

> **tldr;** В конечном итоге использование S3-совместимого объектного хранилища и/или виртуальных таблиц технически нецелесообразно по причинам производительности и подвержено ошибкам из-за ограничений памяти.

Мы провели несколько экспериментов, приведших к нашему окончательному решению SQLite, описанному выше.

Одним из них была попытка использовать [rclone]() и SQLite вместе с S3-совместимым уровнем хранения.

Этот эксперимент позволил нам глубже понять и обнаружить пограничные случаи, связанные с использованием rclone, SQLite и [VFS](https://en.wikipedia.org/wiki/Virtual_file_system):

* Если включить флаг `--vfs-cache-mode writes` с помощью rclone, чтение будет разрешено, однако запись будет кэшироваться.
* Если у вас несколько глобально распределённых серверов IMAP, кэширование на них будет отключено, если только у вас нет одного сервера записи и нескольких прослушивателей (например, подход «публикация/подписка»).
* Это невероятно сложно, и любое дополнительное усложнение приведёт к появлению точек отказа.
* S3-совместимые поставщики хранилищ не поддерживают частичные изменения файлов, а это означает, что любое изменение файла `.sqlite` приведёт к полному изменению и повторной загрузке базы данных.
* Существуют и другие решения, такие как `rsync`, но они не ориентированы на поддержку упреждающей записи в журнал («[WAL](https://www.sqlite.org/wal.html)»), поэтому мы в итоге рассмотрели Litestream. К счастью, наше шифрование уже шифрует файлы [WAL](https://www.sqlite.org/wal.html), поэтому нам не нужно полагаться на Litestream. Однако мы пока не уверены в эффективности Litestream для производственной среды и ниже приводим несколько замечаний по этому поводу.
* Использование опции `--vfs-cache-mode writes` (*единственный* способ использовать SQLite поверх `rclone` для записи) попытается скопировать всю базу данных с нуля в память. Обработка одного почтового ящика объёмом 10 ГБ допустима, однако обработка нескольких почтовых ящиков с чрезвычайно большим объёмом хранилища приведёт к ограничению памяти на серверах IMAP и ошибкам `ENOMEM`, ошибкам сегментации и повреждению данных. * Если вы попытаетесь использовать SQLite [Виртуальные столы](https://www.sqlite.org/vtab.html) (например, [s3db](https://github.com/jrhy/s3db)) для размещения данных на совместимом с S3 уровне хранения, вы столкнетесь с рядом других проблем:
* Чтение и запись будут крайне медленными, поскольку к конечным точкам API S3 необходимо будет обращаться с помощью HTTP-методов `GET`, `PUT`, `HEAD` и `POST`.
* Тестирование разработки показало, что превышение от 500 тыс. до 1 млн записей в оптоволоконном интернет-соединении по-прежнему ограничено пропускной способностью записи и чтения к провайдерам, совместимым с S3. Например, наши разработчики использовали циклы `for` для выполнения как последовательных SQL-операторов `INSERT`, так и операторов, выполняющих массовую запись больших объёмов данных. В обоих случаях производительность была поразительно низкой.
* Виртуальные таблицы **не могут иметь индексы**, операторы `ALTER TABLE` и [другой](https://stackoverflow.com/a/12507650) [ограничения](https://sqlite.org/lang_createvtab.html), что приводит к задержкам до 1-2 минут и более в зависимости от объёма данных.
* Объекты хранились незашифрованными, а встроенная поддержка шифрования отсутствует.
* Мы также исследовали использование [sqlite-s3vfs](https://github.com/uktrade/sqlite-s3vfs), который концептуально и технически аналогичен предыдущему пункту (поэтому у него те же проблемы). Одним из вариантов было бы использование специальной сборки `sqlite3`, защищённой шифрованием, например, [wxSQLite3](https://github.com/utelle/wxsqlite3) (которую мы сейчас используем в нашем решении, описанном выше), через [редактирование установочного файла](https://github.com/rogerbinns/apsw/blob/a870bda57ce28704f028af44c392b9a458e702be/setup.py#L268-L276).
* Другим потенциальным подходом было использование [мультиплексное расширение](https://www.sqlite.org/src/doc/trunk/src/test_multiplex.c), однако оно имеет ограничение в 32 ГБ и потребует сложных задач по сборке и разработке.
* `ALTER TABLE` — это обязательные операторы (что полностью исключает использование виртуальных таблиц). Для корректной работы нашего хука с `knex-schema-inspector` нам необходимы операторы `ALTER TABLE`, которые гарантируют сохранность данных и преобразование извлечённых строк в корректные документы в соответствии с определениями нашей схемы `mongoose` (включая проверку ограничений, типов переменных и произвольных данных).

* Практически все S3-совместимые проекты, связанные с SQLite в сообществе разработчиков ПО с открытым исходным кодом, написаны на Python (а не на JavaScript, который мы используем на 100%).


Библиотеки сжатия, такие как [sqlite-zstd](https://github.com/phiresky/sqlite-zstd) (см. [комментарии](https://news.ycombinator.com/item?id=32303762)), выглядят многообещающе, но [может быть еще не готов к использованию в производстве](https://github.com/phiresky/sqlite-zstd#usage). Вместо этого сжатие на стороне приложения для таких типов данных, как `String`, `Object`, `Map`, `Array`, `Set` и `Buffer`, будет более чистым и простым подходом (и его также легче переносить, поскольку мы могли бы хранить флаг или столбец `Boolean` – или даже использовать `PRAGMA` `user_version=1` для сжатия или `user_version=0` без сжатия в качестве метаданных базы данных). * К счастью, в нашем хранилище сервера IMAP уже реализована дедупликация вложений. Поэтому каждое сообщение с одинаковым вложением не будет сохранять копию. Вместо этого для нескольких сообщений и цепочек в почтовом ящике хранится одно вложение (и впоследствии используется внешняя ссылка).
* Проект Litestream, представляющий собой решение для репликации и резервного копирования SQLite, очень перспективен, и мы, скорее всего, будем использовать его в будущем.
* Не хочу дискредитировать автора(ов), поскольку мы ценим их работу и вклад в развитие открытого исходного кода уже более десяти лет. Однако, судя по реальному использованию, существуют [может быть много головных болей](https://github.com/benbjohnson/litestream/issues) и [потенциальная потеря данных при использовании](https://github.com/benbjohnson/litestream/issues/218).
* Восстановление из резервной копии должно быть простым и беспроблемным. Использование такого решения, как MongoDB с `mongodump` и `mongoexport`, не только утомительно, но и требует много времени и сложной настройки. * Базы данных SQLite упрощают задачу (это всего лишь один файл).
* Мы хотели разработать решение, позволяющее пользователям в любой момент забрать свой почтовый ящик и уйти.
* Простые команды Node.js для `fs.unlink('mailbox.sqlite'))` безвозвратно удаляют данные с диска.
* Аналогично, мы можем использовать совместимый с S3 API с HTTP `DELETE` для легкого удаления снимков и резервных копий пользователей.
* SQLite оказался самым простым, быстрым и экономичным решением.

### Отсутствие альтернатив {#lack-of-alternatives}

Насколько нам известно, ни один другой сервис электронной почты не разработан подобным образом и не имеет открытого исходного кода.

Мы *думаем, что это может быть связано* с тем, что существующие сервисы электронной почты используют устаревшие технологии в производстве с [спагетти-код](https://en.wikipedia.org/wiki/Spaghetti_code) :spaghetti:.

Большинство, если не все, существующих поставщиков услуг электронной почты либо имеют закрытый исходный код, либо рекламируются как имеющие открытый исходный код, **но на самом деле только их интерфейс имеет открытый исходный код.**

**Самая конфиденциальная часть электронной почты** (фактическое взаимодействие с хранилищем/IMAP/SMTP) **выполняется на внутреннем интерфейсе (сервере), а *не* на внешнем интерфейсе (клиенте)**.

### Попробуйте пересылку электронной почты {#try-out-forward-email}

Зарегистрируйтесь сегодня по адресу <https://forwardemail.net>! :rocket: